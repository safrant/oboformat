<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<link href="owl.css" rel="stylesheet" type="text/css" />
<link href="wg.css" rel="stylesheet" type="text/css" />
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The OBO Flat File Format Guide, version 1.4</title>
<!--#include file="page-head.html" -->
</head>
<body>
	<!--#include file="header.html" -->
	<div id="wrapper">
		<!-- page content starts here -->
		<div id="main">
			<h1>The OBO Flat File Format Guide, version&nbsp;1.4</h1>
			<p>
				<span id="author">Chris Mungall</span> <br> <span id="author">Amelia
					Ireland</span> <br>
			</p>
			<p>
				<strong>DRAFT</strong>
			</p>
			<p>
				OBO format is the text file format used by <a rel="external"
					href="http://www.oboedit.org">OBO-Edit</a>, the open source,
				platform-independent application for viewing and editing ontologies.
			</p>
			<p>
				This document is intended as a companion guide to the OBO-Format, in
				the style of the <a href="GO.format.obo-1_2.html">OBO 1.2 file
					format guide</a>. It is not intended as a <i>formal</i> specification
				of syntax or semantics - this is available as a seperate document,
				the OBO Format Syntax and Semantics available at <a
					href="http://purl.obolibrary.org/obo/oboformat/spec.html">http://purl.obolibrary.org/obo/oboformat/spec.html</a>
				document. <b>The formal specification is normative, this
					document is only a guide</b>.
			</p>
			<p>
				The official website for OBO Format documentation and software is <a
					href="http://purl.obolibrary.org/obo/oboformat/">http://purl.obolibrary.org/obo/oboformat/</a>
			</p>
			<p>This document supersedes the obsolete 1.3 specification.
				Syntactic changes are minimal.</p>
			<div class="new">
				<p>
					Any changes between OBO-Format 1.2 and 1.4 are either in <span
						class="new_txt">highlighted text</span>, or with a coloured bar at
					the left side of the page. See <a href="#S.4">further on in
						this document</a> for a summary of these changes.
				</p>
			</div>
			<div id="navPage">
				<ul>
					<li class="h2"><a href="#S.0">Abstract</a></li>
					<li class="h2"><a href="#S.1">OBO Format Syntactic
							Structure</a></li>
					<li class="h3"><a href="#S.1.1">OBO Document Structure</a></li>
					<li class="h3"><a href="#S.1.2">Comments</a></li>
					<li class="h3"><a href="#S.1.4">Tag-Value Pairs</a></li>
					<li class="h3"><a href="#S.1.4">Trailing Modifiers</a></li>
					<li class="h3"><a href="#S.1.5">Escape characters</a></li>
					<li class="h3"><a href="#S.1.6">ID Syntax</a></li>
					<li class="h2"><a href="#S.2">Built-in OBO Semantics</a></li>
					<li class="h3"><a href="#S.2.1">Document Header Tags</a></li>
					<li class="h3"><a href="#S.2.2">Stanzas</a></li>
					<li class="h2"><a href="#S.3">Parsers and Serializers</a></li>
					<li class="h3"><a href="#S.3.1">General Behavior</a></li>
					<li class="h3"><a href="#S.3.2">Handling Unrecognized Tags</a>
					</li>
					<li class="h3"><a href="#S.3.3">Non-Roundtripping Header
							Tags</a></li>
					<li class="h3"><a href="#S.3.4">Dangling References</a></li>
					<li class="h3"><a href="#S.3.5">Serializer Conventions</a></li>
					<li class="h2"><a href="#S.4">Changes in version 1.4</a></li>
					<li class="h3"><a href="#S.4.1">Changes that break
							forwards compatibility</a></li>
					<li class="h3"><a href="#S.4.2">Forwards compatible
							changes</a></li>
				</ul>
			</div>
			<div class="block">
				<h2 id="S.0">Abstract</h2>
				<p>The OBO flat file format is for representing ontologies and
					controlled vocabularies.</p>
				<p>The format itself attempts to achieve the following goals:</p>
				<ul class="dot">
					<li>Human readability</li>
					<li>Ease of parsing</li>
					<li>Extensibility</li>
					<li>Minimal redundancy</li>
				</ul>
				<p class="toTop">
					<a href="#top" title="Back to the top of the page">Back to top</a>
				</p>
			</div>
			<div class="block">
				<h2 id="S.1">OBO Format Syntactic Structure</h2>
				<p>
					The format is similar to the tag-value format of the GO definitions
					file, with a few modifications. One important difference is that <em>unrecognized
						tags in any context do not necessarily generate fatal errors</em>
					(although some parsers may decide to do so; see <a href="#S.2">Parser
						Requirements</a> below). This allows parsers to read files that
					contain information not used by a particular tool.
				</p>
				<h3 id="S.1.1">OBO Document Structure</h3>
				<p>An OBO document is structured as follows:</p>
				<div class="fmt">
					<p>
						<code>
							&lt;header&gt; <br> <br> &lt;stanza&gt; <br>
							&lt;stanza&gt; <br> ...
						</code>
					</p>
				</div>
				<p>Blank lines are ignored.</p>
				<p>
					The header is an unlabeled section at the beginning of the document
					containing <a href="#S.1.4">tag-value pairs</a>. The header ends
					when the first stanza is encountered.
				</p>
				<p>
					A stanza is a labeled section of the document, indicating that an
					object of a particular type is being described. Stanzas consist of
					a stanza name in square brackets, and a series of <a href="#S.1.4">tag-value
						pairs</a>, structured as follows:
				</p>
				<div class="fmt">
					<p>
						<code>
							[&lt;Stanza name&gt;] <br> &lt;tag-value pair&gt; <br>
							&lt;tag-value pair&gt; <br> &lt;tag-value pair&gt;
						</code>
					</p>
				</div>
				<h3 id="S.1.2">Comments</h3>
				<p>
					An OBO file may contain any number of lines beginning with
					<code>!</code>
					, at any point in the file. These lines are ignored by parsers.
				</p>
				<p>
					Further, any line may end with a
					<code>!</code>
					comment. Parsers that encounter an unescaped
					<code>!</code>
					will ignore the
					<code>!</code>
					and all data until the end of the line.
					<code>\&lt;newline&gt;</code>
					sequences are not allowed in
					<code>!</code>
					comments (see <a href="#S.1.5">escape characters</a>).
				</p>
				<h3 id="S.1.4">Tag-Value Pairs</h3>
				<p>Tag-value pairs consist of a tag name, an unescaped colon,
					the tag value, and a newline:</p>
				<div class="fmt">
					<p>
						<code> &lt;tag&gt;: &lt;value&gt; {&lt;trailing
							modifiers&gt;} ! &lt;comment&gt; </code>
					</p>
				</div>
				<p>The tag name is always a string. The value is always a
					string, but the value string may require special parsing depending
					on the tag with which it is associated.</p>
				<p>
					In general, tag-value pairs occur on a single line. Multi-line
					values are possible using escape characters (see <a href="#S.1.5">escape
						characters</a>).
				</p>
				<p>
					In general, each stanza type expects a particular set of
					pre-defined tags. However, a stanza may contain <em>any</em> tag.
					If a parser does not recognize a tag name for a particular stanza,
					no error will be generated. This allows new experimental tags to be
					added without breaking existing parsers. See <a href="#S.3.2">handling
						unrecognized tags</a> for specifics.
				</p>
				<h3 id="S.1.4">Trailing Modifiers</h3>
				<p>Any tag-value pair may be followed by a trailing modifier.
					Trailing modifiers have been introduced into the OBO 1.2
					Specification to allow the graceful addition of new features to
					existing tags.</p>
				<p>A trailing modifier has the following structure:</p>
				<div class="fmt">
					<p>
						<code> {&lt;name&gt;=&lt;value&gt;, &lt;name=value&gt;,
							&lt;name=value&gt;} </code>
					</p>
				</div>
				<p>That is, trailing modifiers are lists of name-value pairs.</p>
				<p>
					Parser implementations may choose to decode and/or round-trip these
					trailing modifiers. However, this is <strong>not</strong> required.
					A parser may choose to ignore or strip away trailing modifiers.
				</p>
				<p>For this reason, trailing modifiers should only include
					information that is optional or experimental.</p>
				<p>
					Trailing modifiers may also occur within dbxref definitions (see <a
						href="#S.2.2.3">dbxref formatting</a>).
				</p>
				<h3 id="S.1.5">Escape characters</h3>
				<div class="new">note: this section needs to be brought in
					line with the formal spec.</div>
				<p>Tag names and values may contain the following escape
					characters:</p>
				<dl class="tableMid codeList">
					<dt>\n</dt>
					<dd>newline</dd>
					<dt>\W</dt>
					<dd>single space</dd>
					<dt>\t</dt>
					<dd>tab</dd>
					<dt>\:</dt>
					<dd>colon</dd>
					<dt>\,</dt>
					<dd>comma</dd>
					<dt>\&quot;</dt>
					<dd>double quote</dd>
					<dt>\\</dt>
					<dd>backslash</dd>
					<dt>\(</dt>
					<dd>open parenthesis</dd>
					<dt>\)</dt>
					<dd>close parenthesis</dd>
					<dt>\[</dt>
					<dd>open bracket</dd>
					<dt>\]</dt>
					<dd>close bracket</dd>
					<dt>\{</dt>
					<dd>open brace</dd>
					<dt>\}</dt>
					<dd>close brace</dd>
					<dt>@</dt>
					<dd>at (language tag)</dd>
					<dt>\&lt;newline&gt;</dt>
					<dd>&lt;no value&gt;</dd>
				</dl>
				<p>Escaped characters should only be used when a literal
					character is needed (that is, a character that the parser should
					not interpret as having a special meaning when parsing). Some tag
					values may contain unescaped colons, brackets, quotes, etc., that
					have meaning in decoding the tag value. Unescaped spaces between
					the separator colon and the start of the value tag are discarded.</p>
				<p>
					OBO parser implementations may support only these escape
					characters, or they may assume that <em>any</em> character
					following a backslash is an escaped character. Parsers that choose
					the latter approach will translate
					<code>\a</code>
					and
					<code>\?</code>
					to "a" and "?" respectively.
				</p>
				<div class="new">
					<h3 id="S.1.6">Identifier Syntax</h3>
					<p>
						Identifiers (IDs) in OBO should be strings consisting of an
						IDSpace concatenated to a LocalID via a <strong>:</strong> (colon)
						character. The ID should not contain any whitespace. The IDSpace
						should not itself contain any colon characters, and should ideally
						be registered on the <a
							href="http://www.geneontology.org/cgi-bin/xrefs.cgi">GO xrefs
							page</a> or with <a href="http://obofoundry.org/">OBO</a>.
					</p>
				</div>
				<p class="toTop">
					<a href="#top" title="Back to the top of the page">Back to top</a>
				</p>
			</div>
			<div class="block">
				<h2 id="S.2">Built-in OBO Semantics</h2>
				<h3 id="S.2.1">Document Header Tags</h3>
				<h4>Required tags</h4>
				<dl class="tableWide codeList">
					<dt>format-version</dt>
					<dd>
						Gives the OBO specification version that this file uses. This is
						useful if tag semantics change from one OBO specification version
						to the next. Cardinality: <strong>zero or one</strong>.
					</dd>
				</dl>
				<h4>Optional tags</h4>
				<dl class="tableWide codeList">
					<dt>data-version</dt>
					<dd>
						Gives the version of the current ontology. This gets translated to
						versionIRI in OWL. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>version</dt>
					<dd>
						Deprecated. Use
						<code>data-version</code>
						instead.
					</dd>
					<dt>ontology</dt>
					<dd>
						The ID space of this ontology. This <strong>should</strong>
						correspond to to the ID prefix of the terms that belong to that
						ontology, translated to lowercase. For GO, the value of this field
						will be "go". For the cell ontology (i.e. the ontology that
						contains CL:0000001), the value will be "cl". If the obo document
						contains some alternative cut or extension of the ontology (for
						example, a GO slim, or an ontology merged with another), then the
						ontology <strong>should</strong> be of form "X/Y", where X is the
						basic ontology name, and Y identifies the cut. For example
						go/gosubset_prok. A URI is also permitted in here. In the
						translation to OWL, the usual default prefix rules will apply,
						with the ".owl" suffix. E.g. "go" will be treated as
						"http://purl.obo-library.org/obo/go.owl"
					</dd>
					<dt>date</dt>
					<dd>
						The current date in dd:MM:yyyy HH:mm format (note: for historic
						reasons, this is NOT a ISO 8601 date, as is the case for the
						creation-date field) . Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>saved-by</dt>
					<dd>
						The username of the person to last save this file. The meaning of
						"username" is entirely up to the application that generated the
						file. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>auto-generated-by</dt>
					<dd>
						The program that generated the file. Cardinality: <strong>zero
							or one</strong>.
					</dd>
					<dt>subsetdef</dt>
					<dd>
						A description of a term subset. The value for this tag should
						contain a subset name, a space, and a quote enclosed subset
						description, as follows:
						<div class="fmt">
							<p>
								<code> subsetdef: GO_SLIM "GO Slim" </code>
							</p>
						</div>
						Cardinality: <strong>any</strong>.
					</dd>
					<dt>import</dt>
					<dd>
						A url or ontology ID referencing another OBO document.
						<div class="new">
							Previously this was interpreted as a directive to download and
							merge the referenced file. This is no longer the case. The
							semantics are now identical to OntologyImports in OWL.
							</new>
							. Parsers must translate simple ontology IDs (e.g. "go") to full
							URIs using the same expansion as for the ontology header tag
							(e.g. http://purl.obolibrary.org/obo/go.owl). Parsers may use
							different mechanisms for resolving the URL. For example, they may
							use a catalog.xml file. The imported document MUST be in either
							obo format or an OWL concrete syntax. Cardinality: <strong>any</strong>.

						
					</dd>
					<dt>synonymtypedef</dt>
					<dd>
						A description of a user-defined synonym type. The value for this
						tag should contain a synonym type name, a space, a quote enclosed
						description, and an optional scope specifier, as follows:
						<div class="fmt">
							<p>
								<code> synonymtypedef: UK_SPELLING "British spelling"
									EXACT </code>
							</p>
						</div>
						<p>
							The scope specifier indicates the default scope for any synonym
							that has this type. See the synonym section of <a href="#S.2.2.2">tags
								in a term stanza</a> for more information on the scope specifier.
							Cardinality: <strong>any</strong>.

						</p>
					</dd>
					<dt>idspace</dt>
					<dd>
						A mapping between a "local" ID space and a "global" ID space. The
						value for this tag should be a local idspace, a space, a URI,
						optionally followed by a quote-enclosed description, like this:
						<div class="fmt">
							<p>
								<code> idspace: GO urn:lsid:bioontology.org:GO: "gene
									ontology terms" </code>
							</p>
						</div>
						Cardinality: <strong>any</strong>.

					</dd>
					<dt>default-relationship-id-prefix</dt>
					<dd>
						Any relationship lacking an ID space will be prefixed with the
						value of this tag. For example:
						<div class="fmt">
							<p>
								<code> default-relationship-id-prefix: OBO_REL </code>
							</p>
						</div>
						<p>The above will make sure that all relations referred to in
							the current file come from the OBO relations ontology, unless
							otherwise specified.</p>
						<p>
							The scope of this tag is within the current file only. See also
							<code>id-mapping</code>
							, below
						</p>
						Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>id-mapping</dt>
					<dd>
						Maps a Term or Typedef ID to another Term or Typedef ID. The main
						reason for this tag is to increase interoperability between
						different OBO ontologies.
						<div class="fmt">
							<p>
								<code> id-mapping: part_of OBO_REL:part_of </code>
							</p>
						</div>
						<p>
							This maps all cases of the unqualified relationship
							<code>part_of</code>
							to the ID
							<code>OBO_REL:part_of</code>
							defined in the OBO relations ontology
						</p>
						<p>
							The scope of this tag is within the current file only. Note that
							the
							<code>default-relationship-id-prefix</code>
							tag takes precedence over this tag
						</p>
						Cardinality: <strong>any</strong>
					</dd>
					<dt>remark</dt>
					<dd>
						General comments for this file. This tag is differentiated from a
						<code>!</code>
						comment in that the contents of a
						<code>remark</code>
						tag are guaranteed to be preserved by a parser. Cardinality: <strong>any</strong>

					</dd>
				</dl>
				<p>The following tags are new in OBO 1.4:</p>
				<div class="new">
					<dl class="tableWide codeList">
						<dt>treat-xrefs-as-equivalent</dt>
						<dd>
							The value for this tag should contain an ID Space. Ideally one
							declared <a href="http://www.geneontology.org/cgi-bin/xrefs.cgi">here</a>
							<p>Macro. Treats all xrefs coming from a particular ID-Space
								as being statements of exact equivalence. Normally, xrefs have
								no special meaning beyond "This xref is of relevance to the
								current entity".</p>
							<p>Example:</p>
							<div class="fmt">
								<p>
									<code>
										treat-xrefs-as-equivalent: CL <br> . <br> . <br>
										. <br> [Term] <br> id: GO:0005623 <br> name:
										cell <br> xref: CL:0000000
									</code>
								</p>
							</div>
							<p>This declares CL:0000000 and GO:0005623 to be equivalent
								in what they reference.</p>
							Cardinality: <strong>any</strong>

						</dd>
						<dt>treat-xrefs-as-genus-differentia</dt>
						<dd>
							The value for this tag should contain an ID Space followed by a
							relation and then a class filler. Cardinality: <strong>any</strong>.

							<p>Macro. Treats all xrefs coming from a particular ID-Space
								as being genus-differentia definitions (cross products, logical
								definitions, intersection definitions). Normally, xrefs have no
								special meaning beyond "This xref is of relevance to the current
								entity".</p>
							<p>Example:</p>
							<div class="fmt">
								<p>
									<code>
										treat-xrefs-as-genus-differentia: CL part_of NCBITaxon:7955 <br>
										. <br> . <br> [Term] <br> id: ZFA:0000134 <br>
										name: neuron <br> xref: ZFIN:ZDB-ANAT-010921-563 <br>
										xref: CL:0000540 <br>
									</code>
								</p>
							</div>
							<p>is treated as if it states:</p>
							<div class="fmt">
								<p>
									<code>
										[Term] <br> id: ZFA:0000134 <br> name: neuron <br>
										xref: ZFIN:ZDB-ANAT-010921-563 <br> intersection_of:
										CL:0000540 <br> intersection_of: part_of NCBITaxon:7955
									</code>
								</p>
							</div>
						</dd>
						<dt>treat-xrefs-as-relationship</dt>
						<dd>
							The value for this tag should contain an ID Space followed by a
							relation ID. Cardinality: <strong>any</strong>

							<p>Macro. Treats all xrefs coming from a particular ID-Space
								as being relationships. Normally, xrefs have no special meaning
								beyond "This xref is of relevance to the current entity".</p>
							<p>Example:</p>
							<div class="fmt">
								<p>
									<code> treat-xrefs-as-relationship: MA homologous_to </code>
								</p>
							</div>
							<p>This declares all xrefs to MA to be homology
								relationships.</p>
						</dd>
						<dt>treat-xrefs-as-is_a</dt>
						<dd>
							The value for this tag should contain an ID Space. Cardinality: <strong>any</strong>

							<p>Macro. Treats all xrefs coming from a particular ID-Space
								as being is_a relationships. Normally, xrefs have no special
								meaning beyond "This xref is of relevance to the current
								entity".</p>
							<p>Example:</p>
							<div class="fmt">
								<p>
									<code> treat-xrefs-as-is_a: CL </code>
								</p>
							</div>
							<p>This declares all xrefs to CL to be is_a relations.</p>
						</dd>
						<dt>relax-unique-identifier-assumption-for-namespace</dt>
						<dd>
							The value for this tag should be a namespace
							<p>By default, an obo namespace (note: not ID-space)
								partitions all the entities such that no two entities belonging
								to the same namespace may be equivalent. This header tag relaxes
								this assumption.</p>
							<p>Note that this assumption does not hold by default
								*between* namespaces (it is OK for cellular_component and cell
								to use different identifiers to denote the type "cell").</p>
							<p>It is unlikely that this tag will be used frequently. One
								scenario in which it may be useful is if a single ontology is
								created from multiple sources, with redundancy:</p>
							<div class="fmt">
								<p>
									<code> relax-unique-identifier-assumption-for-namespace:
										my_combined_ontology </code>
								</p>
							</div>
							Cardinality: <strong>any</strong>

						</dd>
						<dt>relax-unique-label-assumption-for-namespace</dt>
						<dd>
							The value for this tag should be a namespace
							<p>By default, an obo namespace (note: not ID-space)
								partitions all the entities such that no two entities belonging
								to the same namespace may have the same name tag (obsolete
								entities omitted). This header tag relaxes this assumption.</p>
							<p>Note that this assumption does not hold by default
								*between* namespaces (it is OK for mouse_anatomy and fma to use
								the same names).</p>
							<p>It is recommended that the unique label assumption should
								be maintained at all times. However, there may be times at an
								early stage of ontology development where this is relaxed.</p>
							<div class="fmt">
								<p>
									<code> relax-unique-label-assumption-for-namespace:
										my_combined_ontology </code>
								</p>
							</div>
							Cardinality: <strong>any</strong>
						</dd>
					</dl>
				</div>
				<h3 id="S.2.2">Stanzas</h3>
				<p>
					At present, all Term, Typedef and Instance stanzas always begin
					with an
					<code>id</code>
					tag. The value of the
					<code>id</code>
					tag announces the object to which the rest of the tags in the
					stanza refer. Normal, non-anonymous
					<code>id</code>
					s have global scope. An object has the same
					<code>id</code>
					in every file, and in every namespace. See <a href="#S.1.6">ID
						Syntax</a>.
				</p>
				<p>
					The
					<code>id</code>
					tag may be optionally followed by an
					<code>is_anonymous</code>
					tag. If the value of
					<code>is_anonymous</code>
					is true, the object is anonymous. The
					<code>id</code>
					of an anonymous object is not fixed; if the ontology is parsed and
					then reserialized, the
					<code>id</code>
					may change. Anonymous
					<code>id</code>
					s have local scope; they are only valid in the file from which they
					were loaded. The same anonymous
					<code>id</code>
					in two different files refers to <em>a different object</em> in
					each file.
				</p>
				<p>
					Any given stanza <em>does not</em> have to contain all the required
					tags. A file (or collection of files) may contain multiple stanzas
					that describe different aspects of an object. A <em>required</em>
					tag must be specified at least once for each object in a given set
					of files. This makes it possible for optional information to be
					stored in a separate file, and only loaded when necessary.
				</p>
				<p>This means that parsers must wait until the end of the parse
					batch to check whether required information is missing. Multiple
					descriptions may produce parse errors if:</p>
				<ol>
					<li>A stanza contains tags that contradict a previous stanza
						(ie one term description gives a different term name than another
						description)</li>
					<li>A parser has processed all the files in a batch, but an
						object is still missing some required value (such as a term name).
					</li>
				</ol>
				<p>
					There are currently three supported stanza types:
					<code>[Term]</code>
					,
					<code>[Typedef]</code>
					,
					<code>[Instance]</code>
					. Parsers/serializers will round-trip (successfully load and save)
					unrecognized stanzas.
				</p>
				<h4 id="S.2.2.1">Stanza Types</h4>
				<dl>
					<dt>Term</dt>
					<dd>
						Term stanzas constitute the nodes in an ontology graph. Formally a
						Term stanza is equivalent to a <strong>Class</strong> declaration
						in OWL.
					</dd>
					<dt>Typedef</dt>
					<dd>
						Typedef stanzas constitute the edge labels that may be used in an
						ontology graph. Also known as relations, relationship types,
						properties or predicates. The name "Typedef" is somewhat confusing
						but is retained for forwards compatibility. Formally equivalent to
						a <strong>property</strong> in OWL.
					</dd>
					<dt>Instance</dt>
					<dd>Instance stanzas are used to represent the spatiotemporal
						particulars that instantiate types. Note that instances are
						typically not represented in ontologies. OBO allows them for
						completeness, to allow generalized data exchange and for
						compatibility with other languages.</dd>
				</dl>
				<h4 id="S.2.2.2">Tags in a [Term] Stanza</h4>
				<h5>Required tags</h5>
				<dl class="tableWide codeList">
					<dt>id</dt>
					<dd>
						The unique id of the current term. Cardinality: <strong>exactly
							one</strong>.
					</dd>
				</dl>
				<h5>Optional tags</h5>
				<dl class="tableWide codeList">
					<dt>name</dt>
					<dd>
						The term name. Any term may have only <strong>zero or one</strong>
						name defined. Cardinality: <strong>zero or one</strong> - If
						multiple term names are defined, it is a parse error. <span
							class="new_txt">In 1.2 name was required. This has been
							relaxed in 1.4. This helps with OWL interoperability, as labels
							are optional in OWL</span>
					</dd>
					<dt>is_anonymous</dt>
					<dd>
						Whether or not the current object has an anonymous id.
						Cardinality: <strong>zero or one</strong>. The semantics are the
						same as B-Nodes in RDF.
					</dd>
					<dt>alt_id</dt>
					<dd>
						Defines an alternate id for this term. Cardinality: <strong>any</strong>.
						A term may have any number of alternate ids.
					</dd>
					<dt>def</dt>
					<dd>
						The definition of the current term. Cardinality: <strong>zero
							or one</strong>. More than one definition for a term generates a parse
						error. The value of this tag should be the quote enclosed
						definition text, followed by a dbxref list containing dbxrefs that
						describe the origin of this definition (see <a href="#S.2.2.3">dbxref
							formatting</a> for information on how dbxref lists are encoded). An
						example of this tag would look like this:
						<div class="fmt">
							<p>
								<code> definition: "The breakdown into simpler components
									of (+)-camphor, a bicyclic monoterpene ketone." [UM-BBD:pathway
									"", http://umbbd.ahc.umn.edu/cam/cam_map.html ""] </code>
							</p>
						</div>
					</dd>
					<dt>comment</dt>
					<dd>
						A comment for this term. Cardinality: <strong>zero or one</strong>.
						There must be zero or one instances of this tag per term
						description. More than one comment for a term generates a parse
						error.
					</dd>
					<dt>subset</dt>
					<dd>
						This tag indicates a term subset to which this term belongs. The
						value of this tag must be a subset name as defined in a
						<code>subsetdef</code>
						tag in the file header. If the value of this tag is not mentioned
						in a
						<code>subsetdef</code>
						tag, a parse error will be generated. Cardinality: <strong>any</strong>.
						A term may belong to any number of subsets.
					</dd>
					<dt>synonym</dt>
					<dd>
						This tag gives a synonym for this term, some xrefs to describe the
						origins of the synonym, and may indicate a synonym category or
						scope information. Cardinality: <strong>any</strong>.
						<p>The value consists of a quote enclosed synonym text, a
							scope identifier, an optional synonym type name, and an optional
							dbxref list, like this:</p>
						<div class="fmt">
							<p>
								<code> synonym: "The other white meat" EXACT
									MARKETING_SLOGAN [MEAT:00324, BACONBASE:03021] </code>
							</p>
						</div>
						<p>
							The synonym scope may be one of four values:
							<code>EXACT</code>
							,
							<code>BROAD</code>
							,
							<code>NARROW</code>
							,
							<code>RELATED</code>
							. If the first form is used to specify a synonym, the scope is
							assumed to be
							<code>RELATED</code>
							.
						</p>
						<p>
							The synonym type must be the id of a synonym type defined by a
							<code>synonymtypedef</code>
							line in the header. If the synonym type has a default scope, that
							scope is used regardless of any scope declaration given by a
							synonym tag.
						</p>
						<p>
							The dbxref list is formatted as specified in <a href="#S.2.2.3">dbxref
								formatting</a>. A term may have any number of synonyms.
						</p>
					</dd>
					<dt>exact_synonym</dt>
					<dd>
						Deprecated. An alias for the
						<code>synonym</code>
						tag with the scope modifier set to
						<code>EXACT</code>
						.
					</dd>
					<dt>narrow_synonym</dt>
					<dd>
						Deprecated. An alias for the
						<code>synonym</code>
						tag with the scope modifier set to
						<code>NARROW</code>
						.
					</dd>
					<dt>broad_synonym</dt>
					<dd>
						Deprecated. An alias for the
						<code>synonym</code>
						tag with the scope modifier set to
						<code>BROAD</code>
						.
					</dd>
					<dt>xref</dt>
					<dd>
						A dbxref that describes an analagous term in another vocabulary
						(see <a href="#S.2.2.3">dbxref formatting</a> for information
						about how the value of this tag must be formatted). Cardinality: <strong>any</strong>.
						A term may have any number of xrefs.
					</dd>
					<dt>xref_analog</dt>
					<dd>
						Deprecated. An alias for the
						<code>xref</code>
						tag.
					</dd>
					<dt>xref_unk</dt>
					<dd>
						Deprecated. An alias for the
						<code>xref</code>
						tag.
					</dd>
					<dt>is_a</dt>
					<dd>
						This tag describes a subclassing relationship between one term and
						another. The value is the id of the term of which this term is a
						subclass. A term may have any number of
						<code>is_a</code>
						relationships. This is equivalent to a SubClassOf axiom in OWL.
						Cardinality: <strong>any</strong>.
						<p>
							Parsers which support trailing modifiers may optionally parse the
							following trailing modifier tags for
							<code>is_a</code>
							:
						</p>
						<div class="fmt">
							<p>
								<code>
									namespace &lt;any namespace id&gt; <br> derived true OR
									false
								</code>
							</p>
						</div>
						<p>
							The
							<code>namespace</code>
							modifier allows the
							<code>is_a</code>
							relationship to be assigned its own namespace (independent of the
							namespace of the superclass or subclass of this
							<code>is_a</code>
							relationship).
						</p>
						<p>
							The
							<code>derived</code>
							modifier indicates that the
							<code>is_a</code>
							relationship was not explicitly defined by a human ontology
							designer, but was created automatically by a reasoner, and could
							be re-derived using the non-derived relationships in the
							ontology.
						</p>
						<p>
							This tag previously supported the
							<code>completes</code>
							trailing modifier. This modifier is now deprecated. Use the
							<code>intersection_of</code>
							tag instead.
						</p>
					</dd>
					<dt>intersection_of</dt>
					<dd>
						Cardinality: <strong>EITHER zero OR two or more</strong>. This tag
						indicates that this term is equivalent to the intersection of
						several other terms. The value is either a term id, or a
						relationship type id, a space, and a term id. For example:
						<div class="fmt">
							<p>
								<code>
									id: GO:0000085 <br> name: G2 phase of mitotic cell cycle <br>
									intersection_of: GO:0051319 ! G2 phase <br>
									intersection_of: part_of GO:0000278 ! mitotic cell cycle
								</code>
							</p>
						</div>
						<p>
							This means that GO:0000085 is equivalent to any term that is both
							a subtype of 'G2 phase' and has a part_of relationship to
							'mitotic cell cycle' (i.e. the G2 phase of the mitotic cell
							cycle). Note that whilst relationship tags specify <em>necessary</em>
							conditions, intersection_of tags specify <em>necessary and
								sufficient</em> conditions.
						</p>
						<p>
							A collection of intersection_of tags appearing in a term is also
							known as a <em>cross-product</em> definition (this is the same as
							what OWL users know as a <em>defined class</em>, employing
							intersectionOf constructs).
						</p>
						<p>
							It is strongly recommended that all intersection_of tags follow a
							<em>genus-differentia</em> pattern. In this pattern, one of the
							tags is directly to a term id (the genus) and the other tags are
							relation term pairs. For example:
						</p>
						<div class="fmt">
							<p>
								<code>
									[Term] <br> id: GO:0045495 name: pole plasm <br>
									intersection_of: GO:0005737 ! cytoplasm <br>
									intersection_of: part_of CL:0000023 ! oocyte
								</code>
							</p>
						</div>
						<p>
							These definitions can be read as sentences, such as <em>a
								pole plasm is equivalent to a cytoplasm that is part_of an
								oocyte</em>
						</p>
						<p>
							If any
							<code>intersection_of</code>
							tags are specified for a term, at least two
							<code>intersection_of</code>
							tags need to be present or it is a parse error. The full
							intersection for the term is the set of <strong>all</strong> ids
							specified by <strong>all</strong> intersection_of tags for that
							term.
						</p>
						<p class="new_txt">
							As of OBO 1.4, this tag <em>may</em> be applied in Typedef
							stanzas
						</p>
					</dd>
					<dt>union_of</dt>
					<dd>
						Cardinality: <strong>EITHER zero OR two or more</strong>. This tag
						indicates that this term represents the union of several other
						terms. The value is the id of one of the other terms of which this
						term is a union.
						<p>
							If any
							<code>union_of</code>
							tags are specified for a term, at least 2
							<code>union_of</code>
							tags need to be present or it is a parse error. The full union
							for the term is the set of <strong>all</strong> ids specified by
							<strong>all</strong> union_of tags for that term.
						</p>
						<p>This tag may not be applied to relationship types.</p>
						<p>
							Parsers which support trailing modifiers may optionally parse the
							following trailing modifier tag for
							<code>disjoint_from</code>
							:
						</p>
						<div class="fmt">
							<p>
								<code> namespace &lt;any namespace id&gt; </code>
							</p>
						</div>
					</dd>
					<dt>disjoint_from</dt>
					<dd>
						Cardinality: <strong>any</strong>. This tag indicates that a term
						is disjoint from another, meaning that the two terms have no
						instances or subclasses in common. The value is the id of the term
						from which the current term is disjoint. This tag may not be
						applied to relationship types.
						<p>
							Parsers which support trailing modifiers may optionally parse the
							following trailing modifier tag for
							<code>disjoint_from</code>
							:
						</p>
						<div class="fmt">
							<p>
								<code>
									namespace &lt;any namespace id&gt; <br> derived true OR
									false
								</code>
							</p>
						</div>
						<p>
							The
							<code>namespace</code>
							modifier allows the
							<code>disjoint_from</code>
							relationship to be assigned its own namespace.
						</p>
						<p>
							The derived modifier indicates that the
							<code>disjoint_from</code>
							relationship was not explicitly defined by a human ontology
							designer, but was created automatically by a reasoner, and could
							be re-derived using the non-derived relationships in the
							ontology.
						</p>
					</dd>
					<dt>relationship</dt>
					<dd>
						Cardinality: <strong>any</strong>. This tag describes a typed
						relationship between this term and another term or terms. The
						value of this tag should be the relationship type id, and then the
						id of the target term, plus, optionally, other target terms. The
						relationship type name must be a relationship type name as defined
						in a typedef tag stanza. The
						<code>[Typedef]</code>
						must either occur in a document in the current parse batch, or in
						a file imported via an import header tag. If the relationship type
						name is undefined, a parse error will be generated. If the id of
						the target term cannot be resolved by the end of parsing the
						current batch of files, this tag describes a "dangling reference";
						see <a href="#S.3.4">the parser requirements section</a> for
						information about how a parser may handle dangling references. If
						a relationship is specified for a term with an
						<code>is_obsolete</code>
						value of true, a parse error will be generated.
						<p>Parsers which support trailing modifiers may optionally
							parse the following trailing modifier tags for relationships:</p>
						<div class="fmt">
							<p>
								<code>
									namespace &lt;any namespace id&gt; <br> inferred true OR
									false <br> cardinality any non-negative integer <br>
									maxCardinality any non-negative integer <br>
									minCardinality any non-negative integer
								</code>
							</p>
						</div>
						<p>
							The
							<code>namespace</code>
							modifier allows the relationship to be assigned its own namespace
							(independant of the namespace of the parent, child, or type of
							the relationship).
						</p>
						<p>
							The
							<code>inferred</code>
							modifier indicates that the relationship was not explicitly
							defined by a human ontology designer, but was created
							automatically by a reasoner, and could be re-derived using the
							non-derived relationships in the ontology.
						</p>
						<p>
							Cardinality qualifiers can be used to specify constraints on the
							number of relations of the specified type any given instance can
							have. For example, in the stanza declaring a
							<code>id: SO:0000634 ! polycistronic mRNA</code>
							, we can say:
							<code> relationship: has_part SO:0000316
								{minCardinality=2} ! CDS </code>
							which means that every instance of a transcript of this type has
							two or more CDS features such that they stand in a has_part
							relationship from the transcript.
						</p>
						<p>
							The semantics of a relationship tag is by default "all-some".
							Formally, in OWL this corresponds to an existential restriction -
							see the <a href="#OWL">OWL</a> section.
						</p>
					</dd>
					<dt>is_obsolete</dt>
					<dd>
						Cardinality: <strong>zero or one</strong>. Whether or not this
						term is obsolete. Allowable values are "true" and "false" (false
						is assumed if this tag is not present). Obsolete terms must have <strong>no</strong>
						relationships, and no defined
						<code>is_a</code>
						,
						<code>inverse_of</code>
						,
						<code>disjoint_from</code>
						,
						<code>union_of</code>
						, or
						<code>intersection_of</code>
						tags.
					</dd>
					<dt>replaced_by</dt>
					<dd>
						Cardinality: <strong>any</strong>. Gives a term which replaces an
						obsolete term. The value is the id of the replacement term. The
						value of this tag can safely be used to automatically reassign
						instances whose
						<code>instance_of</code>
						property points to an obsolete term.
					</dd>
					<dd>
						The
						<code>replaced_by</code>
						tag may only be specified for obsolete terms. A single obsolete
						term may have more than one
						<code>replaced_by</code>
						tag. This tag can be used in conjunction with the
						<code>consider</code>
						tag.
					</dd>
					<dt>consider</dt>
					<dd>
						Cardinality: <strong>any</strong>. Gives a term which may be an
						appropriate substitute for an obsolete term, but needs to be
						looked at carefully by a human expert before the replacement is
						done.
					</dd>
					<dd>
						This tag may only be specified for obsolete terms. A single
						obsolete term may have many
						<code>consider</code>
						tags. This tag can be used in conjunction with
						<code>replaced_by</code>
						.
					</dd>
					<dt>use_term</dt>
					<dd>
						Deprecated. Equivalent to
						<code>consider</code>
						.
					</dd>
					<dt>builtin</dt>
					<dd>
						Cardinality: <strong>zero or one</strong>. Whether or not this
						term or relation is built in to the OBO format. Allowable values
						are "true" and "false" (false assumed as default). Rarely used.
						One example of where this is used is the OBO relations ontology,
						which provides a stanza for the <span class="rel">is_a</span>
						relation, even though this relation is axiomatic to the language.
					</dd>
				</dl>
				<p>Additional tags in 1.4:</p>
				<dl class="new">
					<dt>created_by</dt>
					<dd>
						Cardinality: <strong>zero or one</strong>. Name of the creator of
						the term. May be a short username, initials or ID. Example: dph
						<p>Note that although this tag is defined in obof1.4, it can
							be used in obof1.2 harmlessly</p>
					</dd>
					<dt>creation_date</dt>
					<dd>
						Cardinality: <strong>zero or one</strong>. Date of creation of the
						term specified in ISO 8601 format. Example: 2009-04-13T01:32:36Z
						<p>Note that although this tag is defined in obof1.4, it can
							be used in obof1.2 harmlessly</p>

					</dd>
				</dl>
				<h4 id="S.2.2.3">Dbxref Formatting</h4>
				<p>Dbxref definitions take the following form:</p>
				<div class="fmt">
					<p>
						<code> &lt;dbxref name&gt; {optional-trailing-modifier} </code>
					</p>
				</div>
				<p>or</p>
				<div class="fmt">
					<p>
						<code> &lt;dbxref name&gt; "&lt;dbxref description&gt;"
							{optional-trailing-modifier} </code>
					</p>
				</div>
				<p>
					The dbxref is a colon separated key-value pair. The key should be
					taken from <a href="http://www.geneontology.org/cgi-bin/xrefs.cgi">GO.xrf_abbs</a>
					but this is not a requirement. If provided, the dbxref description
					is a string of zero or more characters describing the dbxref.
					DBXref descriptions are rarely used and as of obof1.4 are
					discouraged.
				</p>
				<p>Dbxref lists are used when a tag value must contain several
					dbxrefs. Dbxref lists take the following form:</p>
				<div class="fmt">
					<p>
						<code> [&lt;dbxref definition&gt;, &lt;dbxref
							definition&gt;, ...] </code>
					</p>
				</div>
				<p>The brackets may contain zero or more comma separated dbxref
					definitions. An example of a dbxref list can be seen in the GO def
					for "ribonuclease MRP complex":</p>
				<div class="fmt">
					<p>
						<code> def: "A ribonucleoprotein complex that contains an
							RNA molecule of the snoRNA family, and cleaves the rRNA precursor
							as part of rRNA transcript processing. It also has other roles:
							In S. cerevisiae it is involved in cell cycle-regulated
							degradation of daughter cell-specific mRNAs, while in mammalian
							cells it also enters the mitochondria and processes RNAs to
							create RNA primers for DNA replication." [GOC:sgd_curators,
							PMID:10690410, PMID:14729943, PMID:7510714] </code>
					</p>
				</div>
				<p>
					Note that the trailing modifiers (like all trailing modifiers) do
					not need to be decoded or round-tripped by parsers; trailing
					modifiers can always be optionally ignored. However, all parsers
					must be able to gracefully ignore trailing modifiers. It is
					important to recognize that lines which accept a dbxref list may
					have a trailing modifier for each dbxref in the list, and <em>another</em>
					trailing modifier for the line itself.
				</p>
				<h4 id="S.2.2.4">Tags in [Typedef] Stanza</h4>
				<p>
					<code>[Typedef]</code>
					stanzas support almost all the same tags as a
					<code>[Term]</code>
					stanza.
				</p>
				<div class="new">
					<p>
						In OBO Format 1.2, the following tags were not allowed in a
						<code>[Typedef]</code>
						stanza. In 1.4 they <b>are</b> allowed.
					</p>
					<ul>
						<li><code>union_of</code></li>
						<li><code>intersection_of</code></li>
						<li><code>disjoint_from</code></li>
					</ul>
				</div>
				<p>
					The following additional tags are <em>only</em> allowed in a
					<code>[Typedef]</code>
					stanza:
				</p>
				<dl class="tableXtraWide codeList">
					<dt>domain</dt>
					<dd>
						The id of a term, or a special reserved identifier, which
						indicates the domain for this relationship type. If a property P
						has domain D, then any term T that has a relationship of type P to
						another term is a subclass of D. Note that this does <strong>not</strong>
						mean that the domain restricts which classes of terms can have a
						relationship of type P to another term. Rather, it means that any
						term that has a relationship of type P to another term is <em>by
							definition</em> a subclass of D. Cardinality: <strong>zero or
							one</strong>. If the intent is to declare a disjunctive domain, then a new
						class must be declared and defined using the
						<code>union_of</code>
						construct.

					</dd>
					<dt>range</dt>
					<dd>
						The id of a term, or a special reserved identifier, which
						indicates acceptable range for this relationship type. If a
						property P has range R, then any term T that is the target of a
						relationship of type P is a subclass of R. Note that this does <strong>not</strong>
						mean that the range restricts which classes of terms can be the
						target of relationships of type P. Rather, it means that any term
						that is the target of a relationship of type P is <em>by
							definition</em> a subclass of R. Cardinality: <strong>zero or
							one</strong>. If the intent is to declare a disjunctive range, then a new
						class must be declared and defined using the
						<code>union_of</code>
						construct.

					</dd>
					<dt>inverse_of</dt>
					<dd>
						The id of another relationship type that is the inverse of this
						relationship type. If relation A is the inverse_of type B, and X
						has relationship A to Y, then it is implied that Y has relation B
						to X. <span class="new_txt">In obof1.2 the semantics of
							inverse_of were unclear, as obof1.2 unofficially allowed
							type-level relations. In obof1.4, the semantics are identical to
							OWL</span>. Cardinality: <strong>any</strong>.
					</dd>
					<dt>transitive_over</dt>
					<dd>
						The id of another relationship type that this relationship type is
						transitive over. If P is transitive over Q, and the ontology has X
						P Y and Y Q Z then it follows that X P Z (term/type level).
						Equivalent to property chains in OWL2. Cardinality: <strong>any</strong>.
					</dd>
					<dt>is_cyclic</dt>
					<dd>
						Whether or not a cycle can be made from this relationship type. If
						a relationship type is non-cyclic, it is illegal for an ontology
						to contain a cycle made from user-defined <em>or</em> implied
						relationships of this type. Allowed values: true or false.
						Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>is_reflexive</dt>
					<dd>
						Whether this relationship is reflexive. All reflexive
						relationships are also cyclic. Allowed values: true or false.
						Term/type level. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>is_symmetric</dt>
					<dd>
						Whether this relationship is symmetric. All symmetric
						relationships are also cyclic. Allowed values: true or false.
						Term/type level. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>is_anti_symmetric</dt>
					<dd>
						Whether this relationship is anti-symmetric. Allowed values: true
						or false. Term/type level. Cardinality: <strong>zero or
							one</strong>.
					</dd>
					<dt>is_transitive</dt>
					<dd>
						Whether this relationship is transitive. Allowed values: true or
						false. Term/type level. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>is_metadata_tag</dt>
					<dd>
						Whether this relationship is a metadata tag. Properties that are
						marked as metadata tags are used to record object metadata. Object
						metadata is additional information about an object that is useful
						to track, but does not impact the definition of the object or how
						it should be treated by a reasoner. Metadata tags might be used to
						record special term synonyms or structured notes about a term, for
						example. Cardinality: <strong>zero or one</strong>.
					</dd>
					<dt>is_class_level</dt>
					<dd>
						Whether this relation is a class-level relation. In OBO-Format,
						all relationship tags are taken by default to mean an all-some
						relationship over an instance level relation. This tag is used for
						other cases, e.g. lacks_part. In OWL this is translated to a
						hasValue restriction. Cardinality: <strong>zero or one</strong>.
					</dd>
				</dl>
				<h4 id="S.2.2.5">Tags in an [Instance] Stanza</h4>
				<h5>Required tags</h5>
				<dl class="tableWide codeList">
					<dt>id</dt>
					<dd>
						The unique id of the current term. Cardinality: <strong>exactly
							one</strong>.
					</dd>
				</dl>
				<h5>Optional tags</h5>
				<dl class="tableWide codeList">
					<dt>name</dt>
					<dd>
						The instance name. Cardinality: <strong>zero or one</strong>. Any
						instance may have only <strong>one</strong> name defined.
					</dd>
					<dt>instance_of</dt>
					<dd>
						The term id that gives the class of which this is an instance.
						Cardinality: <strong>zero or one</strong>. If an instance belongs
						to multiple classes then a class intersection must be declared.
					</dd>
					<dt>property_value</dt>
					<dd>
						This tag binds a property to a value in this instance. The value
						of this tag is a relationship type id, a space, and a value
						specifier. The value specifier may have one of two forms; in the
						first form, it is just the id of some other instance, relationship
						type or term. In the second form, the value is given by a quoted
						string, a space, and datatype identifier. See <a href="#S.1.6">IDs</a>
						for more information on legal datatype identifiers.
						<div class="fmt">
							<p>
								<code>
									[Instance] <br> id: john <br> name: John Day-Richter
									<br> instance_of: boy <br> property_value: married_to
									heather <br> property_value: shoe_size "8"
									xsd:positiveInteger
								</code>
							</p>
						</div>
						Cardinality: <strong>any</strong>.
					</dd>
				</dl>
				<p>
					The following optional tags are also allowable for instances. They
					have exactly the same syntax and semantics as defined in <a
						href="#S.2.2.2">tags in a term stanza</a>:
				</p>
				<ul>
					<li>is_anonymous</li>
					<li>namespace</li>
					<li>alt_id</li>
					<li>comment</li>
					<li>xref</li>
					<li>synonym</li>
					<li>created_by</li>
					<li>creation_date</li>
					<li>is_obsolete</li>
					<li>replaced_by</li>
					<li>consider</li>
				</ul>
				<p>
					The
					<code>replaced_by</code>
					and
					<code>consider</code>
					tags are also allowable for obsolete instances, but they must refer
					to another instance, rather than another term, to use as a
					replacement.
				</p>
			</div>
			<div class="block">
				<h2 id="S.3">Parsers and Serializers</h2>
				<h3 id="S.3.1">General Behavior</h3>
				<p>All parsers should be capable of failing gracefully and
					generating errors explaining the failure. Parsers may optionally be
					capable of generating warnings, if the file being read contains
					non-fatal errors.</p>
				<h3 id="S.3.2">Handling Unrecognized Tags</h3>
				<p>A parser may do one of several things when an unrecognized
					tag is found:</p>
				<ul class="sampList">
					<li><samp>FAIL</samp>: report a fatal error and terminate
						parsing</li>
					<li><samp>WARN</samp>: report a warning, but continue parsing
						and ignore the unrecognized tag</li>
					<li><samp>WARN_AND_RECORD</samp>: report a warning, but record
						the unrecognized tag for later serialization</li>
					<li><samp>IGNORE</samp>: silently ignore the unrecognized tag
					</li>
					<li><samp>RECORD</samp>: record the unrecognized tag for later
						serialization <em>(recommended)</em></li>
				</ul>
				<h3 id="S.3.3">Non-Roundtripping Header Tags</h3>
				<p>The following optional header tags need not survive
					round-tripping:</p>
				<ul>
					<li>format-version</li>
					<li>version</li>
					<li>date</li>
					<li>saved-by</li>
					<li>auto-generated-by</li>
				</ul>
				<p>They do not need to be round tripped, because the correct
					values will change when the file is saved.</p>
				<h3 id="S.3.4">Dangling References</h3>
				<p>There are several options when a dangling reference is
					encountered</p>
				<ul class="sampList">
					<li><samp>FAIL</samp>: report a fatal error and terminate
						parsing</li>
					<li><samp>WARN_AND_IGNORE</samp>: report a fatal error and
						ignore the dangling reference</li>
					<li><samp>WARN_AND_READ</samp>: report a warning and read in
						the dangling reference, storing it in a form suitable for
						round-tripping</li>
					<li><samp>READ</samp>: silently read and store the dangling
						relationship <em>(recommended)</em></li>
				</ul>
				<h3 id="S.3.5">Serializer Conventions</h3>
				<p>Any parser should be able to read correctly formatted files
					in any layout. However, it is suggested that serializers obey the
					following conventions to ensure consistency, and to facilitate file
					comparison (for example in CVS).</p>
				<h4 id="S.3.5.1">General Conventions</h4>
				<ul>
					<li>Within a single file, all tags relating to a single entity
						should appear in the same stanza (thereby minimizing the total
						number of stanzas and keeping all tags regarding a single entity
						in the same place)</li>
					<li>Any time an identifier is referenced (i.e. anywhere other
						than an id: tag), it should be accompanied by the corresponding <code>name</code>
						value in the comments. See this guide for examples.
					</li>
					<li>In any case where the correct ordering of tags is
						ambiguous (for example, if there are two tags with the same name,
						or the ordering is not given in this document), tags should be
						ordered alphabetically, first on the tag name, then on the tag
						value.</li>
				</ul>
				<h4 id="S.3.5.2">Stanza Conventions</h4>
				<p>
					All new stanza declarations should be preceded by a blank line.
					<code>[Typedef]</code>
					stanzas should appear before
					<code>[Term]</code>
					stanzas, and
					<code>[Instance]</code>
					stanzas should appear after
					<code>[Term]</code>
					stanzas. All other stanza types should appear after
					<code>[Instance]</code>
					stanzas, in alphabetical order on the stanza name.
				</p>
				<h4 id="S.3.5.3">Header Tags</h4>
				<p>Header tags should appear in the following order:</p>
				<div class="fmt">
					<ol class="code">
						<li>format-version</li>
						<li>data-version</li>
						<li>date</li>
						<li>saved-by</li>
						<li>auto-generated-by</li>
						<li>import</li>
						<li>subsetdef</li>
						<li>synonymtypedef</li>
						<li>default-namespace</li>
						<li>namespace-id-rule</li>
						<li>idspace</li>
						<li>treat-xrefs-as-equivalent</li>
						<li>treat-xrefs-as-genus-differentia</li>
						<li>treat-xrefs-as-relationship</li>
						<li>treat-xrefs-as-is_a</li>
						<li>remark</li>
						<li>ontology</li>
					</ol>
				</div>
				<h4 id="S.3.5.4">Ordering Term and Typedef stanzas</h4>
				<p>
					<code>[Term]</code>
					,
					<code>[Typdef]</code>
					, and
					<code>[Instance]</code>
					stanzas should be serialized in alphabetical order on the value of
					their id tag.
				</p>
				<h4 id="S.3.5.5">Ordering Term and Typedef tags</h4>
				<p>Term tags should appear in the following order:</p>
				<div class="fmt">
					<ol class="code">
						<li>id</li>
						<li>is_anonymous</li>
						<li>name</li>
						<li>namespace</li>
						<li>alt_id</li>
						<li>def</li>
						<li>comment</li>
						<li>subset</li>
						<li>synonym</li>
						<li>xref</li>
						<li>builtin</li>
						<li>property_value</li>
						<li>is_a</li>
						<li>intersection_of</li>
						<li>union_of</li>
						<li>equivalent_to</li>
						<li>disjoint_from</li>
						<li>relationship</li>
						<li>created_by</li>
						<li>creation_date</li>
						<li>is_obsolete</li>
						<li>replaced_by</li>
						<li>consider</li>
					</ol>
				</div>
				<p>Typedef tags should appear in the following order:</p>
				<div class="fmt">
					<ol class="code">
						<li>id</li>
						<li>is_anonymous</li>
						<li>name</li>
						<li>namespace</li>
						<li>alt_id</li>
						<li>def</li>
						<li>comment</li>
						<li>subset</li>
						<li>synonym</li>
						<li>xref</li>
						<li>property_value</li>
						<li>domain</li>
						<li>range</li>
						<li>builtin</li>
						<li>holds_over_chain</li>
						<li>is_anti_symmetric</li>
						<li>is_cyclic</li>
						<li>is_reflexive</li>
						<li>is_symmetric</li>
						<li>is_transitive</li>
						<li>is_functional</li>
						<li>is_inverse_functional</li>
						<li>is_a</li>
						<li>intersection_of</li>
						<li>union_of</li>
						<li>equivalent_to</li>
						<li>disjoint_from</li>
						<li>inverse_of</li>
						<li>transitive_over</li>
						<li>equivalent_to_chain</li>
						<li>disjoint_over</li>
						<li>relationship</li>
						<li>is_obsolete</li>
						<li>created_by</li>
						<li>creation_date</li>
						<li>replaced_by</li>
						<li>consider</li>
						<li>expand_assertion_to</li>
						<li>expand_expression_to</li>
						<li>is_metadata_tag</li>
						<li>is_class_level</li>

					</ol>
				</div>
				<p>Instance tags should appear in the following order:</p>
				<div class="fmt">
					<ol class="code">
						<li>id</li>
						<li>is_anonymous</li>
						<li>name</li>
						<li>namespace</li>
						<li>alt_id</li>
						<li>def</li>
						<li>comment</li>
						<li>subset</li>
						<li>synonym</li>
						<li>xref</li>
						<li>instance_of</li>
						<li>property_value</li>
						<li>relationship</li>
						<li>created_by</li>
						<li>creation_date</li>
						<li>is_obsolete</li>
						<li>replaced_by</li>
						<li>consider</li>
					</ol>
				</div>
				<h4 id="S.3.5.6">Dbxref lists</h4>
				<p>Values in dbxref lists should be ordered alphabetically on
					the dbxref name.</p>
				<h4 id="S.3.5.7">Clause order</h4>
				<div>
					Clauses of the with the same tag should be sorted in the following
					way:
					<ol>
						<li>If tag is intersection_of, first sort the intersection_of
							clauses into groups by values count, prefer short ones.</li>
						<li>The sort keys are the clause values and their string
							representation. The sort order is alphabetically and
							case-insensitive.</li>
						<li>If two values are equal, alphabetically, case-sensitive</li>
					</ol>
				</div>
				<p class="toTop">
					<a href="#top" title="Back to the top of the page">Back to top</a>
				</p>
			</div>
			<div class="block">
				<h2 id="S.4">Changes in 1.4</h2>
				<h3 id="S.4.1">Changes that break forwards compatibility</h3>
				<ul>
					<li>All string values are treated as instances of <a
						rel="external"
						href="http://www.w3.org/2007/OWL/wiki/InternationalizedStringSpec#Definition_of_the_rdf:text_Datatype">rdf:text</a>.
						String values that lack '@' a followed by a valid language tag are
						treated as if they have a trailing '@'. Strings that should
						genuinely contain the '@' character must escape it. This is
						technically a forwards-incompatible change in that it changes the
						semantics of strings. However, it is syntactically forwards
						compatible.
					</li>
					<li>The semantics of <strong>inverse_of</strong> were not
						clear in 1.2. In 1.4, relations are instance-level and this tag
						has the same meaning as the InverseProperties in OWL2.
					</li>
					<li>Use of the backslash character "\" to split a tag over
						multiple lines was never used in practice and has been deprecated.
					</li>
					<li>Unicode support. TODO.</li>
				</ul>
				<h4>New Header Tags</h4>
				<h5>Header Macros</h5>
				<ul>
					<li>treat-xrefs-as-equivalent</li>
					<li>treat-xrefs-as-genus-differentia</li>
					<li>treat-xrefs-as-relationship</li>
					<li>treat-xrefs-as-is_a</li>
					<li>relax-unique-identifier-assumption-for-namespace</li>
					<li>relax-unique-label-assumption-for-namespace</li>
				</ul>
				<h5>Definitional Expressions</h5>
				<p>
					ID Definitional Expressions added. E.g. <strong>GO:0005737^part_of(CL:0000023)</strong>
					can be used wherever one wants to say "cytoplasm of oocyte". This
					is treated as if it has the following definition:
				</p>
				<div class="fmt">
					<p>
						<code>
							[Term] <br> id: GO:0005737^part_of(CL:0000023) <br>
							intersection_of: GO:0005737 ! cytoplasm <br>
							intersection_of: part_of CL:0000023 ! oocyte
						</code>
					</p>
				</div>
				<p>This is known as post-composition. We can refer to an unnamed
					entity (i.e. one with no ID in any ontology) by describing it via a
					logical expression. The The Obolog document for the formal
					semantics of these expressions.</p>
				<h5>Relation Tags</h5>
				<p>Many of these are advanced features that can safely be
					ignored by parsers.</p>
				<dl class="tableWide codeList">
					<dt>holds_over_chain</dt>
					<dd>
						See <a
							href="http://wiki.geneontology.org/index.php/Relation_composition">Relation
							Composition</a>. This is an extension of the transitive_over tag,
						introduced in 1.2. The equivalent construct in OWL is a property
						chain.
						<code> holds_over_chain(R R1 R2) ==> R1(x y) R2(y z) -> R(x
							z) </code>

					</dd>
					<dt>equivalent_to_chain</dt>
					<dd>
						See <a
							href="http://wiki.geneontology.org/index.php/Relation_composition">Relation
							Composition</a>. This is an extension of the transitive_over tag,
						introduced in 1.2.
						<code> equivalent_to_chain(R R1 R2) ==> R1(x y) R2(y z) ->
							R(x z) </code>
						<code> equivalent_to_chain(R R1 R2) ==> R(x z) -> exists y:
							R1(x y) R2(y z) </code>

					</dd>
					<dt>disjoint_over</dt>
					<dd>
						For example: <strong>spatially_disconnected_from</strong> is
						disjoint_over part_of, in that two disconnected entities have no
						parts in common. This can be translated to OWL as:
						<code> disjoint_over(R S), R(A B) ==> (S some A)
							disjointFrom (S some B) </code>

					</dd>
					<dt>intersection_of</dt>
					<dd>
						Previously, this tag could only be used in [Term] stanzas, to
						define types/classes/universals/patterns. Now it can be used to
						define relations. For example, we can define a temporal relation
						coincides_with as being true if both start end end boundaries are
						shared.
						<div class="fmt">
							<p>
								<code>
									[Typedef] <br> id: coincides_with <br>
									intersection_of: has_same_start_as <br> intersection_of:
									has_same_end_as
								</code>
							</p>
						</div>
					</dd>
					<dt>union_of</dt>
					<dd>Previously, this tag could only be used in [Term] stanzas,
						to define types/classes/universals/patterns. Now it can be used to
						define relations</dd>
					<dt>is_functional</dt>
					<dd>Relation acts like a function. E.g. any entity only
						relates to one other entity by this relation. Identical to OWL
						FunctionalProperty</dd>
					<dt>is_inverse_functional</dt>
					<dd>Like is_functional, but the opposite "direction".
						Identical to OWL InverseFunctionalProperty</dd>
				</dl>
				<h5>Tags for either relations or types/classes</h5>
				<dl class="tableWide codeList">
					<dt>equivalent_to</dt>
					<dd>Used to specify exact equivalence between two instances,
						types or relations . Identical to OWL EquivalentClasses</dd>
				</dl>
				<p class="toTop">
					<a href="#top" title="Back to the top of the page">Back to top</a>
				</p>
				<h4 id="OWL">
					OBO and OWL
					</h5>

					<p>
						The formal specification of the mapping between OBO format syntax
						and OWL is provided in the <a
							href="http://purl.obolibrary.org/obo/oboformat/spec.html">The
							OBO Syntax and Semantics</a> document. The intention is that
						OBO-Format can be regarded as a syntax expressing a subset of
						OWL2.
					</p>
					<p></p>
					<h5>Translating basic relationships to OWL</h5>
					<p>
						An
						<code>is_a</code>
						tag is translated to a subclass axiom, and all relationships are
						treated by default as all-some (existential). See later for
						advanced features for representing other kinds of quantification.
					</p>

					<p>
						<code>
							[Term]<br> id: GO:0000085<br> name: G2 phase of mitotic
							cell cycle<br> is_a: GO:0051319 ! G2 phase<br> <br>
						</code>
						translates to
						<code>
							<br> Class: GO_0000085<br> Annotations: label 'G2 phase
							of mitotic cell cycle'@en<br> SubClassOf: GO:0051319<br>
						</code>
					</p>

					<p>
						<code>
							[Term]<br> id: GO:0000085<br> name: G2 phase of mitotic
							cell cycle<br> relationship: part_of GO:0051329 ! interphase
							of mitotic cell cycle<br>
						</code>
						translates to
						<code>
							<br> Class: GO_0000085<br> Annotations: label 'G2 phase
							of mitotic cell cycle'@en<br> SubClassOf: part_of some
							GO_0051329<br>
						</code>
					</p>

					<h5>Translating intersection_of tags to OWL</h5>
					<p>
						A collection of OBO
						<code>intersection_of</code>
						tags are translated to an owl intersection construct. There is an
						implicit equivalence axiom.
					</p>

					<p>
						<code>
							[Term]<br> id: GO:0000085<br> name: G2 phase of mitotic
							cell cycle<br> intersection_of: GO:0051319 ! G2 phase<br>
							intersection_of: part_of GO:0000278 ! mitotic cell cycle<br>
						</code>
						translates to
						<code> Class: GO_0000085 Annotations: label 'G2 phase of
							mitotic cell cycle'@en EquivalentTo: GO:0051319 and part_of some
							GO_0000278 </code>
					</p>
					<h5>Translating OBO metadata</h5>
					<p>The IAO ontology-metadata ontology is used for metadata.</p>
					<p>
						<code> [Term] id: GO:0000087 name: M phase of mitotic cell
							cycle namespace: biological_process def: "M phase occurring as
							part of ...." [GOC:dph, GOC:mah, ISBN:0815316194] synonym:
							"M-phase of mitotic cell cycle" EXACT [] xref: Reactome:1006743
							"M Phase" is_a: GO:0000279 ! M phase intersection_of: GO:0000279
							! M phase intersection_of: part_of GO:0000278 ! mitotic cell
							cycle relationship: part_of GO:0000278 ! mitotic cell cycle </code>
						translates to
						<code>
							Class: GO_0000087<br> Annotations:<br> label 'M phase
							of mitotic cell cycle'@en<br> IAO_TODO ??? 'M-phase of
							mitotic cell cycle'@en<br> IAO_TODO Reactome_1006743<br>
							IAO_TODO (IAO_nnnn GOC_dph) TODO "M phase occurring as part of
							...."@en <br>

						</code>
					</p>
					<h5>Quantification of restrictions</h5>
					<p>
					<ul>
						<li>All property-class (P,C) pairs will by default be treated
							as SomeValuesFrom(P,C)</li>
						<li>An exception is made if cardinality is specified, then
							the obvious cardinality OWL2 construct(s) are used</li>
						<li>If a property is declared class-level in the Typedef
							stanza via an is_class_level true tag, then the pair is treated
							as HasValue(P,C). The rationale for this is explained in the
							macros document.</li>
					</ul>
					</p>
					<h5 id="OWL">OWL Macros</h5>
					<p>The following two tags can be used within Typedef stanzas:
					<ul>
						<li><code>expand_expression_to</code> maps to an
							AnnotationAssertion(IAO_0000424 P V)</li>
						<li><code>expand_assertion_to</code> maps to an
							AnnotationAssertion(IAO_0000425 P V)</li>
					</ul>
					These specify macro-expansions. More details can be found in <a
						href="http://github.com/cmungall/obo2owl/raw/f8d31b1838069477b908bce7c6cd1369e5283782/papers/shortcuts-submitted-owled2010.pdf">this
						document</a> and in <a
						href="http://www.slideshare.net/cmungall/macro-discussion-owled-2010">this
						presentation</a>.
					</p>
					<h5>Extensions to OWL2</h5>
					<ul>
						<li>OWL2 prohibits cardinality constraints on transitive
							object properties, but obof1.4 allows this.</li>
						<li>obof1.4 allows property chains in both directions via the
							<code>equivalent_to_chain</code> tag.
						</li>
						<li>obof1.4 allows property definitions via intersection and
							union constructs.</li>
					</ul>
			</div>
		</div>
	</div>
</body>
</html>
